<!doctype html>
<html lang="en">
	<head>
		<title>Sequential GLR demo</title>
		<meta charset="utf-8">
		<style>
			@import url(https://fonts.googleapis.com/css?family=Lato:300italic,700italic,300,700);
			
			body {
				font-family: 'Lato';
				background-color: #f0f0f0;
				margin: 0px auto;
				max-width: 1150px;
			}
			
			#content {
				margin-top : 50px;
				margin-left : auto;
				margin-right : auto;
				max-width: 600px;
			}
			
			h2 {
				font-weight : 400;
			}
			
			.btn {
				font-family: 'Lato';
				font-size: 16px;
				margin-left:0px;
			}

			#controls {
				text-align : center;
			}

			#container {
				width: 500px;
				height: 300px;
				margin: auto;
			}

			#fix_res, #glr_res {
				margin-top:50px;
				width: 200px;
				text-align : center;
			}

			#fix_res {
				float: left;
			}

			#glr_res {
				float: right;
			}

			#est_mean {
				text-align : center;
			}

			input {
				margin-right: 10px;
			}

			span {
				font-size: smaller;
			}

			sup, sub {
			    height: 0;
			    line-height: 1;
			    vertical-align: baseline;
			    _vertical-align: bottom;
			    position: relative;
			}

			sup { bottom: 1ex; }
			sub { top: .5ex; }
		</style>
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-32642923-1']);
			_gaq.push(['_trackPageview']);

			(function() {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();

		</script>
		<script src="./js/jstat.js"></script>
		<script src="./js/SeGLiR.js"></script>
	</head>
	<body>
		<div id="content">
			<h2>Estimate comparison</h2>
			<div id="container">
				<div id="fix_res">
				</div>
				<div id="glr_res">
				</div>
			</div>
			<div id="controls">
				<label for="p1">p<sub>1</sub>:</label>
				<input type="text" value=0.4 id="p1" size="6"></input>
				<label for="p2">p<sub>2</sub>:</label>
				<input type="text" value=0.5 id="p2" size="6"></input>
				<input class="btn" type="button" value="Simulate" onclick="startTest()" id="startbutton"></input>
				<input class="btn" type="button" value="Calculate bias-adjusted MLE" onclick="estimateBiasAdjMLE()" id="bamlebutton" disabled></input>
			</div>
			<p>This is a comparison of A/B testing with a fixed samplesize test versus a sequential GLR test (via <a href="https://github.com/auduno/seglir">SeGLiR</a>). Click "Simulate" to generate data from the given proportions p<sub>1</sub> and p<sub>2</sub> and simulate outcomes and MLE estimates from the test. Click "Calculate bias-adjusted MLE" to calculate the Whitehead bias-adjusted MLE estimate for the sequential GLR test - note that this may take a while to calculate, especially if the true difference is very small.</p>

			<p>Both tests are "comparison of proportions" tests done at α-level 0.05, β-level 0.10, where the null-hypothesis is that p<sub>1</sub> = p<sub>2</sub>, while the alternative hypothesis is that p<sub>1</sub> <span>≠</span> p<sub>2</sub>. We also specify that we are interested in detecting any difference between p<sub>0</sub> and p<sub>1</sub> larger than 0.01. Note that the fixed sample-size test usually gives more precise estimates due to usually having more samples. The sequential GLR also gives biased estimates, which can be corrected by the Whitehead bias-adjusted MLE.</p>
			<p>For more information about the sequential GLR test take a look at <a href="http://auduno.github.io/SeGLiR/documentation/reference.html">the reference of SeGLiR</a>.</p>
			<a href="https://github.com/auduno/seglir"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>
			<script>
				var seq_glr = new glr();

				var p1, p2;
				var test;
				var testRunning = false;
				var fix_samples = 52425; // according to http://powerandsamplesize.com/Calculators/Compare-2-Proportions/2-Sample-Equality

				// function to validate input
				var validateInput = function() {
					p1 = parseFloat(document.getElementById('p1').value)
					p2 = parseFloat(document.getElementById('p2').value)
					if (isNaN(p1) || p1 < 0 || p1 > 1) {
						alert("p1 was not a valid number between 0 and 1")
						return false;
					}
					if (isNaN(p2) || p2 < 0 || p2 > 1) {
						alert("p2 was not a valid number between 0 and 1")
						return false;
					}
					return true;
				}

				// function to start iteration
				var startTest = function() {
					// check test is not running still
					if (testRunning) return;
					// validate input
					if (!validateInput()) return;
					testRunning = true;
					var glrTestDone = false;
					var numSamples = 0;
					var x_sum = 0;
					var y_sum = 0;
					// create instance of seglir
					test = seq_glr.test("bernoulli","two-sided",0.01,0.05,0.1);

					while (numSamples <= fix_samples || !glrTestDone) {
						// pull number
						var x_sample = Math.random() < p1 ? 1 : 0;
						var y_sample = Math.random() < p2 ? 1 : 0;
						numSamples += 1;
						x_sum += x_sample;
						y_sum += y_sample;
						var p1_hat = x_sum/numSamples;
						var p2_hat = y_sum/numSamples;
						
						// apply to glr (if not done) and check if it's done
						if (!glrTestDone) {
							var glr_res = test.addData({x : x_sample, y : y_sample});
							if (typeof(glr_res) != "undefined") {
								// get corrected_estimate
								//var corr_est = test.estimate(100000);
								// render results
								renderGLRResults(numSamples, glr_res == "true",(p1_hat-p2_hat).toFixed(3));
								glrTestDone = true;
							}
						}
						// apply to z-test only if done
						if (numSamples == fix_samples) {
							var z_value = (p1_hat-p2_hat)/Math.sqrt((p1_hat*(1-p1_hat))/numSamples + (p2_hat*(1-p2_hat))/numSamples );
							if (Math.abs(z_value) > 1.96) {
								renderZResults(false,(p1_hat-p2_hat).toFixed(3));
							} else {
								renderZResults(true,(p1_hat-p2_hat).toFixed(3));
							}
						}
					}
					document.getElementById('bamlebutton').disabled = false;

					testRunning = false;
				}

				var estimateBiasAdjMLE = function() {
					var corr_est = test.estimate(100000);
					document.getElementById('glr_res').innerHTML += "<p>Bias-adjusted MLE : "+corr_est[2].toFixed(3)+"</p>";
					document.getElementById('bamlebutton').disabled = true;
				}

				// function to render GLR results
				var renderGLRResults = function(time, result, est) {
					// render number samples
					if (result) {
						var res_string = "p<sub>0</sub> = p<sub>1</sub>";
					} else {
						var res_string = "p<sub>0</sub> ≠ p<sub>1</sub>";
					}
					document.getElementById('glr_res').innerHTML = "<h3>Sequential GLR:</h3><p>Test conclusion : "+res_string+"</p><p>Samples needed : "+time+"</p><p>MLE of (p<sub>0</sub> - p<sub>1</sub>) : "+est+"</p>";
					// render conclusion
				}

				// function to render z-test results
				var renderZResults = function(result, est) {
					// render number samples
					if (result) {
						var res_string = "p<sub>0</sub> = p<sub>1</sub>";
					} else {
						var res_string = "p<sub>0</sub> ≠ p<sub>1</sub>";
					}
					document.getElementById('fix_res').innerHTML = "<h3>Fixed samplesize:</h3><p>Test conclusion : "+res_string+"</p><p>Samples needed : "+fix_samples+"</p><p>MLE of (p<sub>0</sub> - p<sub>1</sub>) : "+est+"</p>";
					// render conclusion
				}
			</script>
		</div>
	</body>
</html>