<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Reference</title>
<link rel="stylesheet" href="./styles/styles.css">
<link rel="stylesheet" href="./styles/coderay.css">
<script src="./javascripts/scale.fix.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="./javascripts/slimbox2.js"></script>
<link rel="stylesheet" href="./styles/slimbox2.css" type="text/css" media="screen" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>-
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="wrapper">
<header>
<h1>
<a href="http://github.com/auduno/seglir/">SeGLiR</a></h1>
<p>Javascript library for rapid A/B-testing with Sequential Generalized Likelihood Ratio Tests</p>
<p class="view">
<a href="https://github.com/auduno/seglir">View the Project on GitHub <small>auduno/SeGLiR</small></a></p>
<ul>
<li><a href="https://github.com/auduno/seglir/zipball/master">Download <strong>ZIP File</strong></a></li>
<li><a href="https://github.com/auduno/seglir/tarball/master">Download <strong>TAR Ball</strong></a></li>
<li><a href="https://github.com/auduno/seglir">Fork On <strong>GitHub</strong></a></li>
</ul>
</header>
<section>
<h1>Library Reference</h1>

<!--<h2 id="process">Flow</h2>-->

<p>SeGLiR is a javascript implementation of A/B-testing (AKA hypothesis testing) via Sequential Generalized Likelihood Ratio Tests. The Sequential Generalized Likelihood Ratio Test is a sequential hypothesis test that will stop as soon as we are able to reject a hypothesis, while still keeping type-1 and type-2 error guarantees. Compared to fixed-sample size tests, this usually gives a significant improvement in the needed samplesize, at the cost of some loss of precision in estimates. The test has been shown<sup><a href="#fn1">1</a></sup> to be <em>uniformly first-order asymptotically optimal</em> with regard to minimizing samplesize for tests based on a exponential family parameter. For a comparison between expected samplesize with Sequential Generalized Likelihood Ratio tests and classical fixed-sample size tests, take a look at this example:</p>

<p>[figure]</p>

<p>Mathematically, we have one or more variables $X$ with a distribution dependent on some parameter $\theta$. We also have two hypotheses $H_0 : \theta \in \Theta_0$ and $H_A : \theta \in \Theta_A$ and want to find out which is most likely based on data, with some guarantees on the Type-1 and Type-2 errors that are acceptable for the test. Typically there is also a small indifference region between $\Theta_0$ and $\Theta_A$ where we don't care about our type-1 and type-2 guarantees. The test will stop at time T, where T is defined as:</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mi>T</mi>
<mo>=</mo>
<mrow>
  <mi>inf</mi>
  <mrow>
    <mo form="prefix">{</mo>
    <mi>n</mi>
    <mo>:</mo>
    <msub>
      <mi>L</mi>
      <mrow>
        <mi>n</mi>
        <mi>a</mi>
      </mrow>
    </msub>
    <mo>&gt;</mo>
    <msub>
      <mi>b</mi>
      <mn>0</mn>
    </msub>
    <mspace width="0.278em" />
    <mtext>or</mtext>
    <mspace width="0.278em" />
    <msub>
      <mi>L</mi>
      <mrow>
        <mi>n</mi>
        <mi>b</mi>
      </mrow>
    </msub>
    <mo>&gt;</mo>
    <msub>
      <mi>b</mi>
      <mn>1</mn>
    </msub>
    <mo form="postfix">}</mo>
  </mrow>
</mrow>
</math>

<p>where</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mrow>
  <msub>
    <mi>L</mi>
    <mrow>
      <mi>n</mi>
      <mi>a</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="1">
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <mi>&theta;</mi>
            <mo>&isin;</mo>
            <mi>&Theta;</mi>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <mi>&theta;</mi>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <msub>
              <mi>&theta;</mi>
              <mn>0</mn>
            </msub>
            <mo>&isin;</mo>
            <msub>
              <mi>&Theta;</mi>
              <mn>0</mn>
            </msub>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <msub>
          <mi>&theta;</mi>
          <mn>0</mn>
        </msub>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
  </mfrac>
  <mspace width="0.278em" />
  <mo>,</mo>
  <mspace width="0.278em" />
  <msub>
    <mi>L</mi>
    <mrow>
      <mi>n</mi>
      <mi>b</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="1">
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <mi>&theta;</mi>
            <mo>&isin;</mo>
            <mi>&Theta;</mi>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <mi>&theta;</mi>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <msub>
              <mi>&theta;</mi>
              <mi>A</mi>
            </msub>
            <mo>&isin;</mo>
            <msub>
              <mi>&Theta;</mi>
              <mi>A</mi>
            </msub>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <msub>
          <mi>&theta;</mi>
          <mi>A</mi>
        </msub>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
  </mfrac>
</mrow>
</math>

<p>and $b_0$ and $b_1$ are some precalculated thresholds so that the test fulfills type-1 and type-2 error guarantees. If $L_{na} > b_0$ at the time of stopping, the null hypothesis is rejected, while if $L_{nb} > b_1$ the alternative hypothesis is rejected.</p>

<p>This library currently implements these tests:</p>
<ul>
  <li>Comparing two bernoulli proportions</li>
  <li>Comparing two gaussian means, with unknown but equal variance</li>
  <li>Selecting the best arm in a two-armed bandit setting, with Î´-PAC guarantees</li>
</ul>

<p>It is easiest to install SeGLiR via node package manager (make sure you have node.js installed):</p>

<pre><code>npm install seglir
</code></pre>

<p>and load via <em>require</em> in node.js.</p>

<pre><code>var glr = require('seglir');
</code></pre>

<p>Generally the library follows the template of creating an instance of a test via :</p>

<pre><code>var test = glr.test(<em>type</em>, <em>sides</em>, <em>indifference_size</em>, <em>alpha</em>, <em>beta</em>);
</code></pre>

<p>where <em>type</em> is the type of the test (for instance "bernoulli"), <em>sides</em> is "two-sided" or "one-sided", <em>indifference_size</em> is the size of the indifference region, <em>alpha</em> is the desired type-1 error, and <em>beta</em> is the desired type-2 error. Note that these parameters may vary depending on the type of test. From the returned instance of the test, you can add datasamples via the function <em>addData()</em>:</p>

<pre><code>test.addData({'x' : 0});
test.addData({'x' : 1, 'y' : 0});
test.addData({'y' : 0});
</code></pre>

<p>If this function returns "true", "false" or "undefined", the test has finished. "true" means the null hypothesis was accepted, while "false" means the alternative hypothesis was accepted.</p>

<h2>Comparison of two bernoulli proportions</h2>

<p>In these tests we assume that we have two random variables, $X$ and $Y$, where $X$ is bernoulli distributed with unknown parameter $p_1$ and $Y$ is bernoulli distributed with unknown parameter $p_2$, and we want to do some inference on the parameters $p_1$ and $p_2$. These tests are what is commonly used in web page testing, for instance for testing conversion.</p>

<p>In the two-sided test we test the hypotheses $H_0 : p_1 = p_2$ versus $H_A : |p_1 - p_2| > \delta$ (where $\delta > 0$ is the size of the indifference region), while in the one-sided test we test the hypotheses $H_0 : p_1 < p_2 - \delta$ versus $H_A : p_1 > p_2 + \delta$. Note that in both cases, this is equivalent to saying we are interested in detecting differences between $p_1$ and $p_2$ larger than $\delta > 0$.</p>

<p>Test creation:</p>

<p>Instance functions</p>

<ul>
<li><em><strong>getResults()</strong></em> : returns an object with sufficient statistics, likelihood ratio statistics, as well as information on whether the test is done.</li>
<li><em><strong>pValue()</strong></em> : if the test is done, this returns a simulated p-value.</li>
<li><em><strong>confInterval()</strong></em> : if the test is done, this returns a bootstrap confidence interval of the difference between $p_1$ and $p_2$.</li>
<li><em><strong>estimate()</strong></em> : if the test is done, this returns whitehead bias-adjusted estimates of $p_1$, $p_2$ and $p_1 - p_2$ respectively.</li>
<li><em><strong>getData()</strong></em> : returns two arrays with the sequences of samples of $X$ and $Y$ collected so far.</li>
<li><em><strong>addData(</strong>{x : 1, y : 1}<strong>)</strong></em> : add data points from samples of $X$ and $Y$ respectively. Note that it's possible to add samples from $X$ and $Y$ separately. Returns <em>undefined</em> until test is finished, when it will return either <em>"true"</em> ($H_A$ was rejected) or <em>"false"</em> ($H_0$ was rejected) as a string. Note that after the test is finished, the instance will still store new data points added internally, but test statistics and conclusion will not be updated. All stored data points collected can be retrieved via <em>getData()</em>.</li>
<li><em><strong>expectedSamplesize(</strong>p1, p2<strong>)</strong></em> : simulates the expected sample size needed for concluding a test with true parameters $p_1$ and $p_2$.</li>
<li><em><strong>maxSamplesize()</strong></em> : returns the worst-case maximum samplesize of this test.</li>
<li><em><strong>properties()</strong></em> : returns an object with properties of this test that were specified on initialization, such as <em>type</em>, <em>sides</em>, <em>indifference size</em>, <em>alpha</em> and <em>beta</em>.</li>
</ul>

<p>A simple example:</p>

<pre><code>var glr = require('seglir');
var test = glr.test("bernoulli","two-sided",0.01,0.05,0.10);
// add data from samples as they come in
test.addData({'x' : 0});
test.addData({'y' : 1});
test.addData({'y' : 1, 'x' : 0});
test.addData({'x' : 0, 'y' : 1});
test.addData({'y' : 1, 'x' : 0}); // returns result "false", i.e. we reject the null-hypothesis
// get estimates of p_1, p_2 and p_1-p_2
test.estimate(); // returns [0, 1, -1]
</code></pre>

<sup>Footnotes:</sup><br/>
<sup id="fn1">1. Tartakovsky, Nikiforov, Basseville : Sequential Analysis, CRC press 2014, <a href="http://books.google.no/books?id=zhsbBAAAQBAJ&lpg=PP1&pg=PA254#v=onepage&q&f=false">Theorem 5.4.1</a></sup>

<!--<h3><a href="/">&lsaquo;&nbsp;&nbsp;back&nbsp;</a></h3>-->
</section>
<footer>
<p>This project is maintained by <a href="https://github.com/auduno">auduno</a></p>
<p><small>Theme originated from <a href="https://github.com/orderedlist">orderedlist</a></small></p>
</footer>
</div>
<!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
</body>
</html>
