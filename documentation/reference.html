<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Reference</title>
<link rel="stylesheet" href="./styles/styles.css">
<link rel="stylesheet" href="./styles/coderay.css">
<script src="./javascripts/scale.fix.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="./javascripts/slimbox2.js"></script>
<link rel="stylesheet" href="./styles/slimbox2.css" type="text/css" media="screen" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>-
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="wrapper">
<header>
<h1>
<a href="http://github.com/auduno/seglir/">SeGLiR</a></h1>
<p>Javascript library for rapid A/B-testing with Sequential Generalized Likelihood Ratio Tests</p>
<p class="view">
<a href="https://github.com/auduno/seglir">View the Project on GitHub <small>auduno/SeGLiR</small></a></p>
<ul>
<li><a href="https://github.com/auduno/seglir/zipball/master">Download <strong>ZIP File</strong></a></li>
<li><a href="https://github.com/auduno/seglir/tarball/master">Download <strong>TAR Ball</strong></a></li>
<li><a href="https://github.com/auduno/seglir">Fork On <strong>GitHub</strong></a></li>
</ul>
</header>
<section>
<h1>Library Reference</h1>

<!--<h2 id="process">Flow</h2>-->

<p>SeGLiR is a javascript implementation of hypothesis testing via Sequential Generalized Likelihood Ratio Tests. This is a sequential test that will stop as soon as we detect a significant difference, in corrr. to fixed sample-size tests, while still keeping type-1 and type-2 error guarantees. This in most cases gives a *significant* improvement in the number of samples needed before concluding a test, and has been shown by for instance Tartakovsky to be "uniformly first-order asymptotically optimal" with regard to minimizing samplesize for tests based on a exponential family parameter.</p>

<p>Mathematically, we have two hypotheses $H_0 : \theta \in \Theta_0$ and $H_A : \theta \in \Theta_A$ and we want to find out which is most likely based on data. Typically there is also a small indifference region between $\Theta_0$ and $\Theta_A$ where we don't care about our type-1 and type-2 guarantees. The test will stop at time T, where T is defined as:</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mi>T</mi>
<mo>=</mo>
<mrow>
  <mi>inf</mi>
  <mrow>
    <mo form="prefix">{</mo>
    <mi>n</mi>
    <mo>:</mo>
    <msub>
      <mi>L</mi>
      <mrow>
        <mi>n</mi>
        <mi>a</mi>
      </mrow>
    </msub>
    <mo>&gt;</mo>
    <msub>
      <mi>b</mi>
      <mn>0</mn>
    </msub>
    <mspace width="0.278em" />
    <mtext>or</mtext>
    <mspace width="0.278em" />
    <msub>
      <mi>L</mi>
      <mrow>
        <mi>n</mi>
        <mi>b</mi>
      </mrow>
    </msub>
    <mo>&gt;</mo>
    <msub>
      <mi>b</mi>
      <mn>1</mn>
    </msub>
    <mo form="postfix">}</mo>
  </mrow>
</mrow>
</math>

<p>where</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mrow>
  <msub>
    <mi>L</mi>
    <mrow>
      <mi>n</mi>
      <mi>a</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="1">
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <mi>&theta;</mi>
            <mo>&isin;</mo>
            <mi>&Theta;</mi>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <mi>&theta;</mi>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <msub>
              <mi>&theta;</mi>
              <mn>0</mn>
            </msub>
            <mo>&isin;</mo>
            <msub>
              <mi>&Theta;</mi>
              <mn>0</mn>
            </msub>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <msub>
          <mi>&theta;</mi>
          <mn>0</mn>
        </msub>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
  </mfrac>
  <mspace width="0.278em" />
  <mo>,</mo>
  <mspace width="0.278em" />
  <msub>
    <mi>L</mi>
    <mrow>
      <mi>n</mi>
      <mi>b</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="1">
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <mi>&theta;</mi>
            <mo>&isin;</mo>
            <mi>&Theta;</mi>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <mi>&theta;</mi>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
    <mrow>
      <mstyle displaystyle="true">
        <munder>
          <mi>sup</mi>
          <mrow>
            <msub>
              <mi>&theta;</mi>
              <mi>A</mi>
            </msub>
            <mo>&isin;</mo>
            <msub>
              <mi>&Theta;</mi>
              <mi>A</mi>
            </msub>
          </mrow>
        </munder>
      </mstyle>
      <mi>L</mi>
      <mrow>
        <mo form="prefix">(</mo>
        <msub>
          <mi>&theta;</mi>
          <mi>A</mi>
        </msub>
        <mo form="postfix">)</mo>
      </mrow>
    </mrow>
  </mfrac>
</mrow>
</math>

<p>and $b_0$ and $b_1$ are some precalculated thresholds so that the test fulfills type-1 and type-2 error guarantees. If $L_{na} > b_0$ at the time of stopping, the null hypothesis is rejected, while if $L_{nb} > b_1$ the alternative hypothesis is rejected.</p>

<p>This library implements tests for comparing two bernoulli proportions, two-sided or one-sided, as well as .... It is easiest to install library via npm and use in node.js.</p>

<pre><code>var glr = require(SeGLiR);
</code></pre>

<p>Generally the library follows the template of creating an instance of a test via :</p>

<pre><code>var test = glr.test(type, sides, indifference_size, alpha, beta);
</code></pre>

<p>where <em>type</em> is the type of the test (for instance "bernoulli"), <em>sides</em> is "two-sided" or "one-sided", <em>indifference_size</em> is the size of the indifference region, <em>alpha</em> is the desired type-1 error, and <em>beta</em> is the desired type-2 error. Note that there may be additional parameters depending on the type of test. From the returned instance of the test, you can then add datasamples via <em>addData()</em>:</p>

<pre><code>test.addData({'x' : 0});
test.addData({'x' : 1, 'y' : 0});
test.addData({'y' : 0});
</code></pre>

<p>If this function returns "true", "false" or "undefined", the test has finished. "true" means the null hypothesis was accepted, while "false" means the alternative hypothesis was accepted.</p>

<h2 id="events">Comparison of two bernoulli proportions</h2>

<p>In these tests we assume that we have two bernoulli samples, $X \sim B(p_1)$ and $Y \sim B(p_2)$, and want to compare p_1 and p_2.</p>

<p><strong>Two-sided test</strong>:</p>

<p>In the two-sided test we test the hypothesis $H_0 : p_1 = p_2$ versus $H_A : p_1 \neq p_2$, where p_1 and p_2 is the proportions in some bernoulli parameter.</p>

<p>Test creation:</p>

<p>Instance functions</p>

<ul>
<li><strong>getResults()</strong> : returns results as a dict {}</li>
<li><strong>pValue()</strong> : returns the simulated p-value</li>
<li><strong>confInterval()</strong> : returns a confidence interval</li>
<li><strong>estimate()</strong> : returns whitehead bias-adjusted estimates of p_1, p_2 and p_1-p_2</li>
<li><strong>getData()</strong> : returns the sequences of data collected so far</li>
<li><strong>addData()</strong> : add data points. Returns ".." if test is finished</li>
<li><strong>expectedSamplesize(p_1, p_2)</strong> : simulates the expected sample size needed for true parameters p_1 and p_2</li>
<li><strong>maxSamplesize()</strong> : returns the worst-case maximum samplesize of this test</li>
<li><strong>properties()</strong> : returns object with properties of this test, such as alpha, beta, etc.</li>
</ul>

<p>A simple example</p>

<pre><code>var test = glr.test("bernoulli","two-sided",0.01,0.05,0.10);
// add data from samples as they come in
test.add({'x' : 0});
test.add({'y' : 1});
test.add({'y' : 1, 'x' : 0});
// stuff
</code></pre>

<h2 id="events">Functions</h2>

<p>These are the functions that the <code>headtrackr.Tracker</code> object exposes:</p>

<ul>
  <li><strong><em>init</em></strong>( <em>video</em>, <em>canvas</em>, <em>setupVideo</em> ) : initialize headtrackr with a video to track faces on.</li>
    <ul>
      <li><em>video</em> : a video element to track faces on</li>
      <li><em>canvas</em> : a canvas element to copy video input to, same size as video</li>
      <li><em>setupVideo</em> (optional) : whether to automatically set up streaming from webcam (or fallback video) to video element or not. (Default is <em>true</em>)</li>
    </ul>
  <li><strong><em>start</em></strong>(  ) : start the tracker. Returns <code>false</code> if the tracker hasn't been initalized first.</li>
  <li><strong><em>stop</em></strong>( ) : stop the running tracker.</li>
  <li><strong><em>stopStream</em></strong>( ) : stop the mediastream from webcam if there is one.</li>
  <li><strong><em>getFOV</em></strong>( ) : get estimated field of view of webcam.</li>
</ul>


<!--<h3><a href="/">&lsaquo;&nbsp;&nbsp;back&nbsp;</a></h3>-->
</section>
<footer>
<p>This project is maintained by <a href="https://github.com/auduno">auduno</a></p>
<p><small>Theme originated from <a href="https://github.com/orderedlist">orderedlist</a></small></p>
</footer>
</div>
<!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
</body>
</html>
